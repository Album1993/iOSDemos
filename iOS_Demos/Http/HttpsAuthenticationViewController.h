//
//  HttpsAuthenticationViewController.h
//  iOS_Demos
//
//  Created by 张一鸣 on 16/01/2018.
//  Copyright © 2018 张一鸣. All rights reserved.
//

#import <UIKit/UIKit.h>

/*！
 Apple CSR CER P12 mobileprovition 到底是什么
 
 CSR（Certificate Signing Request）钥匙串文件 为生成证书做基础，要生成CER证书必须要有CSR私钥，此私钥包含了用户自己的一些信息。这个文件是保存在我们的mac的(keychain)里面的, 此文件包含了(公钥和私钥)
 CER 包含了开发者信息和公钥 （zym： cer 是签名过的共钥，为什么要加这个进项目呢， 原因是我不能确定服务端发给我的公钥是否是真的服务端的公钥，所以拿这个共钥里面的信息以逐一比较，这就是为什么会有三种pin方法）
 （zym： 公钥只在第一次握手的时候使用，之后会生成一个对称加密的key， 之后的所有数据传输都是通过对称加密的算法去实现）
 P12 它不仅包含CER的信息，还有私钥信息，即： P12备份文件 = CER文件 + 私钥；（zym：这个p12是用来做双向认证的，服务端需要有这个p12的经过数字签名的公钥）
 mobileprovition 包含了上述所有内容 Certificate && App ID && Device, 这个Provisioning Profile文件会在打包时嵌入到.ipa的包里。 这是用来双向认证的
 
 ---------------------------------------------------------------------------------------------------------------------------------------

 NSURLSession 对证书的验证

 证书验证方法
 
 在 URLSessionDelegate 中有一个方法 `func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)` 专门用来处理 HTTPS 证书的处理。具体操作可以参考 Pitaya 中的代码。
 
 我简单复述一下处理流程：
 
 1. 发现是 HTTPS 请求，取出证书
 
 2. 进入证书处理流程：（zym： 这个证书有两个方法， 下面代码中的else 中 的代码是对双向认证的客户端发来请求的验证，单向认证就不会调用这个else， 还有，双向认证给服务器的是共钥）
 
    1. 本地证书分两种情况：① 本地存储着证书服务机构颁发的 crt 文件[转换而来的 cer 文件](https://lvwenhan.com/ios/464.html)，使用 NSData 进行内容对比 ② 本地存储着自签名的 cer 格式的证书，使用 NSData 进行内容对比
 
    3. 匹配成功，手动让请求继续，这一步可以让自签名证书绕过 iOS 系统的证书合法性验证
 
    4. 匹配失败，进入错误处理流程
 
    5. 如果自签名证书不做手动处理，那么在这个方法结束后链接就会被系统关闭，因为 root 证书不合法。
 
    所以，在 APP 提交的时候，苹果会检查是否将 ATS 配置为了“全部无脑通过”，这种操作是被禁止的。当然，苹果也可以在系统层面一刀切，但是那样得挂多少个 APP 啊，苹果不会那么做。所以会被影响的应该只是新提交的 ipa。
 
 ---------------------------------------------------------------------------------------------------------------------------------------
 
 SSL 钢钉原理
    AFSecurityPolicy这个类是AFN的设置SSL钢钉的类，有3种验证方式：（zym： 因为数字签名中的数据有很多，所以可以分为不比较，比较一部分， 比较全部）
 
    AFSSLPinningModeNone: 这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。(这个模式是不安全的)
    AFSSLPinningModePublicKey: 代表客户端会将服务器端返回的证书与本地保存的证书中，PublicKey的部分进行校验；如果正确，才继续进行。
    AFSSLPinningModeCertificate: 代表客户端会将服务器端返回的证书和本地保存的证书中的所有内容，包括PublicKey和证书部分，全部进行校验；如果正确，才继续进行。
    2和3都需要把证书内置在 app Bundle中。
    一般情况使用AFSSLPinningModePublicKey就好了，AFN的方法是读取app中所有.cer后缀的文件就行匹配。
    如果直接设置AFSSLPinningModeNone，HTTPS也是能正常访问的，但是就没有校验证书，失去HTTPS的意义。
    简单说：HTTP+SSL/TLS+TCP = HTTPS，只有证书匹配才会完成服务器请求，得到数据。
 
 ---------------------------------------------------------------------------------------------------------------------------------------
 
 关于自签名证书
 
    自签名证书不会被浏览器信任，因为每次有新的 HTTPS 证书到达某个操作系统时，系统会去访问 root 证书的服务器以确定域名证书的身份，这些合法的 root 证书服务商就是固定的那几家，显然自签名证书不会被信任，所以我们在 12306 抢票的时候需要先下载他的自签名证书的 root 证书并手动信任，不然就打不开页面。
 
    我们可以看到，自签名证书的验证在代码层面，在审核的时候是完全不可感知的，所以就没有什么“苹果不接受自签名证书”之类的问题了。而且，自签名证书被广泛的用于各种系统内部的连接加密，不是苹果可以一刀切的：如果粗暴的在操作系统层面阻止了自签名证书，导致企业客户的系统突然挂掉，后果不可想象。
 
关于证书更换
 
    证书都有有效期，在过期之前需要申请新证书，这时候 SSL 钢钉该怎么处理呢？动态下发当然是不行的，为什么要验证证书？就是因为网络不可信任。Pitaya 前两天加入了这个逻辑：在新证书和旧证书交接的一段时间内，上线新版本，同时包含新旧证书，这样可以保证更新过的用户可以对证书更换无感。
 
    另外，设置 SSL 钢钉不适合面向普通用户的 APP，因为总是有人万年不更新，这更适合企业内部 APP，可以通过行政手段及自驱力（业绩啊，提成啊）推动更新。
 
    HTTPS 是支持双向认证的，不过那指的是客户端（浏览器或 APP）也像服务端一样，在发送请求给服务端的时候带上证书，再由服务端使用对应的私钥进行验证。一般 APP 不需要这么做。

 ---------------------------------------------------------------------------------------------------------------------------------------

 tips：
 （1）如何保证公钥不被篡改？
    解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
 （2）公钥加密计算量太大，如何减少耗用的时间？
    解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
 （3）SSL/TLS协议的基本过程是这样的：
     （1） 客户端向服务器端索要并验证公钥。 （双向认证在第一步之后插入一步： 服务端索要客户端公钥）
     （2） 双方协商生成"对话密钥"。
     （3） 双方采用"对话密钥"进行加密通信。
 
 （4）"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。
    是因为对称加密的密钥也是通过可信任的公钥加密后的进行传输，所以必定不会泄密

 （5）至于为什么一定要用三个随机数，来生成"会话密钥"：
     "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
     对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
     pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。
 
 （6）三个密钥生成时间
    1  客户端发出请求
     （1） 支持的协议版本，比如TLS 1.0版。
     （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。
     （3） 支持的加密方法，比如RSA公钥加密。
     （4） 支持的压缩方法。
    2  服务器回应（SeverHello）
     （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
     （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。
     （3） 确认使用的加密方法，比如RSA公钥加密。
     （4） 服务器证书。
    3  客户端回应
     （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。
     （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
     （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
    4  服务器的最后回应
     （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
     （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

 配置细节： https://www.jianshu.com/p/25efb6d8ec8c
 */


@interface HttpsAuthenticationViewController : UIViewController


@end
